<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>PlayStation(R)Mobile SDK: Basic Usage of 2-Dimensional Physics Simulation Physics2D Library</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>




<div id="top">
 <!------------------------1. START------------------------------>
 
         <div id="sonylogo">
             <img src="image/groupLogo.gif" />
         </div>
         
          <div id="projectname">
      <a href="index.html"> <img id="title" src="image/title.png" height="45" width="302" style="margin-left:20px; margin-top:4px;"/></a>
          </div>
          
          <div id="MSearchBox" class="MSearchBoxInactive">
               <span class="left">
                 <img id="MSearchSelect" src="search/mag_sel.png"
                      onmouseover="return searchBox.OnSearchSelectShow()"
                      onmouseout="return searchBox.OnSearchSelectHide()"
                      alt=""/>
                 <input type="text" id="MSearchField" value="Search" accesskey="S"
                      onfocus="searchBox.OnSearchFieldFocus(true)" 
                      onblur="searchBox.OnSearchFieldFocus(false)" 
                      onkeyup="searchBox.OnSearchFieldChange(event)"/>
                 </span><span class="right">
                   <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()">																
                   <img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
                 </span>
           </div>
<!------------------------END------------------------------------->
</div>





<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('physics2d_overview_en.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<h1>Basic Usage of 2-Dimensional Physics Simulation Physics2D Library </h1>  </div>
</div>
<div class="contents">
<div class="textblock"><div class="line-block">
<div class="line">We will check sample scene called &quot;Primitive Scene&quot; to learn how to use 2-dimensional physics simulation Physics2D library.</div>
<div class="line">Please refer &quot;sample/Physics2D/Physics2DSample/BasicScene/PrimitiveScene.cs&quot;</div>
<div class="line"><br /></div>
</div>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#minimal-process-of-creating-physics-simulation-scene" id="id1">Minimal Process of Creating Physics Simulation Scene</a></li>
<li><a class="reference internal" href="#initial-setup-of-rigid-bodies" id="id2">Initial Setup of Rigid Bodies</a></li>
<li><a class="reference internal" href="#create-the-collision-shape" id="id3">Create the Collision Shape</a><ul>
<li><a class="reference internal" href="#example-of-box-shape" id="id4">Example of Box Shape</a></li>
<li><a class="reference internal" href="#example-of-sphere-shape" id="id5">Example of Sphere Shape</a></li>
<li><a class="reference internal" href="#example-of-convex-shape" id="id6">Example of Convex Shape</a></li>
<li><a class="reference internal" href="#number-of-collision-shapes" id="id7">Number of Collision Shapes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#create-the-rigid-body-linked-with-the-collision-shape" id="id8">Create the rigid body linked with the collision shape</a><ul>
<li><a class="reference internal" href="#dynamic-rigid-body" id="id9">Dynamic Rigid Body</a></li>
<li><a class="reference internal" href="#static-rigid-body" id="id10">Static Rigid Body</a></li>
<li><a class="reference internal" href="#kinematic-rigid-body" id="id11">Kinematic Rigid Body</a></li>
<li><a class="reference internal" href="#trigger-rigid-body" id="id12">Trigger Rigid Body</a></li>
<li><a class="reference internal" href="#attribute-used-to-initial-setting-of-a-rigid-body" id="id13">Attribute Used to Initial Setting of a Rigid Body</a></li>
<li><a class="reference internal" href="#example-of-setup-of-static-rigid-body" id="id14">Example of Setup of Static Rigid Body</a></li>
<li><a class="reference internal" href="#example-of-setup-of-dynamic-rigid-body" id="id15">Example of Setup of Dynamic Rigid Body</a></li>
<li><a class="reference internal" href="#example-of-setup-of-kinematic-rigid-body" id="id16">Example of Setup of Kinematic Rigid Body</a></li>
<li><a class="reference internal" href="#characteristic-of-the-scene-setup" id="id17">Characteristic of the Scene Setup</a></li>
<li><a class="reference internal" href="#sleep-of-rigid-body" id="id18">Sleep of Rigid Body</a></li>
</ul>
</li>
<li><a class="reference internal" href="#rendering-of-rigid-body" id="id19">Rendering of Rigid Body</a><ul>
<li><a class="reference internal" href="#preparation-of-vertex-buffer" id="id20">Preparation of Vertex Buffer</a></li>
<li><a class="reference internal" href="#structure-of-collision-shape-physicsshape" id="id21">Structure of Collision Shape PhysicsShape</a></li>
<li><a class="reference internal" href="#acquisition-of-vertex-data-in-the-case-of-sphere" id="id22">Acquisition of Vertex Data in The Case of Sphere</a></li>
<li><a class="reference internal" href="#acquisition-of-vertex-data-in-the-case-of-box-or-general-convex" id="id23">Acquisition of Vertex Data in The Case of Box or General Convex</a></li>
<li><a class="reference internal" href="#rendering-of-shape-of-rigid-bodies" id="id24">Rendering of shape of rigid bodies</a></li>
</ul>
</li>
<li><a class="reference internal" href="#rendering-of-debug-information" id="id25">Rendering of Debug Information</a><ul>
<li><a class="reference internal" href="#debug-rendering-of-collision-point" id="id26">Debug Rendering of Collision Point</a></li>
<li><a class="reference internal" href="#debug-rendering-of-bounding-box" id="id27">Debug Rendering of Bounding Box</a><ul>
<li><a class="reference internal" href="#features-of-2-dimensional-physics-simulation-physics2d-library" id="id28">Features of 2-Dimensional Physics Simulation Physics2D Library</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#joint-setting" id="id29">Joint Setting</a><ul>
<li><a class="reference internal" href="#fixed-both-for-rotation-and-position" id="id30">Fixed both for rotation and position</a></li>
<li><a class="reference internal" href="#example-of-constraint-for-rotation" id="id31">Example of Constraint for Rotation</a></li>
<li><a class="reference internal" href="#example-of-constraint-for-vertical" id="id32">Example of Constraint for Vertical</a></li>
<li><a class="reference internal" href="#example-of-constraint-for-horizontal" id="id33">Example of Constraint for Horizontal</a></li>
</ul>
</li>
</ul>
</div>
<div align="left" class="figure">
<img alt="alternate text" src="image/physics2d/primitive_sample01.png" style="width: 597.0px; height: 335.0px;" />
</div>
<div class="section" id="minimal-process-of-creating-physics-simulation-scene">
<h1><a class="toc-backref" href="#id1">Minimal Process of Creating Physics Simulation Scene</a></h1>
<p>The following is minimal process of creating physics simulation scene.</p>
<ol class="arabic simple">
<li>Create the scene class inherit from PhysicsScene</li>
<li>Override InitScene() of the scene class</li>
<li>Call InitScene() inside constructor of the scene class</li>
</ol>
<p>We will check the code of PrimitiveScene to create the scene class as an example.</p>
<ol class="arabic simple">
<li>Create the scene class inherit from PhysicsScene</li>
</ol>
<div class="highlight"><pre>using System;
using System.Text;

using Sce.PlayStation.Core;
using Sce.PlayStation.Core.Graphics;
using Sce.PlayStation.Core.Input;
using Sce.PlayStation.Core.Environment;

// Include 2D Physics Framework
using Sce.PlayStation.HighLevel.Physics2D;

public class PrimitiveScene : PhysicsScene
{

}
</pre></div>
<!-- end-of-code-block -->
<ol class="arabic simple" start="2">
<li>Override InitScene() of the scene class</li>
</ol>
<div class="highlight"><pre>using System;
using System.Text;

using Sce.PlayStation.Core;
using Sce.PlayStation.Core.Graphics;
using Sce.PlayStation.Core.Input;
using Sce.PlayStation.Core.Environment;

// Include 2D Physics Framework
using Sce.PlayStation.HighLevel.Physics2D;

public class PrimitiveScene : PhysicsScene
{
        public override void InitScene ()
        {
                // Create an empty simulation scene
                base.InitScene();
        }
}
</pre></div>
<!-- end-of-code-block -->
<ol class="arabic simple" start="3">
<li>Call InitScene() inside constructor of the scene class</li>
</ol>
<div class="highlight"><pre>using System;
using System.Text;

using Sce.PlayStation.Core;
using Sce.PlayStation.Core.Graphics;
using Sce.PlayStation.Core.Input;
using Sce.PlayStation.Core.Environment;

// Include 2D Physics Framework
using Sce.PlayStation.HighLevel.Physics2D;

public class PrimitiveScene : PhysicsScene
{
        public PrimitiveScene()
        {
            InitScene();
        }

        public override void InitScene ()
        {
                // Create an empty simulation scene
                base.InitScene();
        }
}
</pre></div>
<!-- end-of-code-block -->
<div class="line-block">
<div class="line">Minimal setup of physics simulation scene is ready now.</div>
<div class="line"><br /></div>
<div class="line">But there are no physics object inside the scene, and simulation will not do anything at all.</div>
<div class="line">Now we should put necessary rigid bodies as the initial state of the scene inside InitScene().</div>
<div class="line"><br /></div>
<div class="line">Then we will check the InitScene() and see how to put rigid bodies as the initial state of the scene.</div>
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="initial-setup-of-rigid-bodies">
<h1><a class="toc-backref" href="#id2">Initial Setup of Rigid Bodies</a></h1>
<p>The following is basic process of initial setup of rigid bodies.</p>
<ol class="arabic simple">
<li>Create the collision shape</li>
<li>Create the rigid body linked with the collision shape</li>
</ol>
</div>
<div class="section" id="create-the-collision-shape">
<h1><a class="toc-backref" href="#id3">Create the Collision Shape</a></h1>
<div class="line-block">
<div class="line">Basically collision shape should be convex shape including sphere, box and usual convex.</div>
<div class="line">Maximum number of vertices of convex shape is 30. But when you modify source codes, you can change this upper limitation.</div>
<div class="line">However, simulation cost will increase in the case that convex contains a lot of vertices.</div>
<div class="line"><br /></div>
</div>
<div align="left" class="figure">
<img alt="alternate text" src="image/physics2d/collision_shape01_e.png" style="width: 600.0px; height: 274.0px;" />
</div>
<div class="line-block">
<div class="line">Concave shape cannot be set to the collision shape directly.</div>
<div class="line">Concave shape should be treated as compound of multiple rigid bodies.</div>
</div>
<div align="left" class="figure">
<img alt="alternate text" src="image/physics2d/collision_shape02_e.png" style="width: 600.0px; height: 285.0px;" />
</div>
<div class="line-block">
<div class="line">Collision shapes of the scene are registered to sceneShapes.</div>
<div class="line">At the same time, please do not forget set numShape and make sure that numShape is equals to number of collision shapes.</div>
<div class="line"><br /></div>
<div class="line">Now we will check the way to set collision shapes inside PrimitiveScene.</div>
</div>
<div class="highlight"><pre>public override void InitScene ()
{
        // Create an empty simulation scene
        base.InitScene();

        ...
        ...
        ...

        // Box Shape Setting PhysicsShape( &quot;width&quot;, &quot;height&quot; )
        Vector2 wall_width = new Vector2(50, 8);
        sceneShapes[0] = new PhysicsShape(wall_width);

        Vector2 wall_height = new Vector2(8, 30);
        sceneShapes[1] = new PhysicsShape(wall_height);

        Vector2 box_width = new Vector2(2.0f, 2.0f);
        sceneShapes[2] = new PhysicsShape(box_width);

        // Sphere Shape Setting PhysicsShape( &quot;radius&quot; )
        float sphere_width = 2.0f;
        sceneShapes[3] = new PhysicsShape(sphere_width);


        Vector2[] test_point = new Vector2[10];

        for (int i = 0; i &lt; 10; i++)
        {
            test_point[i] = new Vector2(rand_gen.Next(-1000, 1000), rand_gen.Next(-1000, 1000)) * 2.0f / 1000.0f;
        }

        // Convex Shape Setting (by using random points)
        sceneShapes[4] = PhysicsShape.CreateConvexHull(test_point, 10);

        numShape = 5;

        ...
        ...
        ...
}
</pre></div>
<!-- end-of-code-block -->
<div class="section" id="example-of-box-shape">
<h2><a class="toc-backref" href="#id4">Example of Box Shape</a></h2>
<p>Half of width and height is given to the constructor of PhysicsShape.</p>
<div class="highlight"><pre>Vector2 wall_width = new Vector2(50, 8);
sceneShapes[0] = new PhysicsShape(wall_width);
</pre></div>
<!-- end-of-code-block -->
</div>
<div class="section" id="example-of-sphere-shape">
<h2><a class="toc-backref" href="#id5">Example of Sphere Shape</a></h2>
<p>Radius is given to the constructor of PhysicsShape.</p>
<div class="highlight"><pre>float sphere_width = 2.0f;
sceneShapes[3] = new PhysicsShape(sphere_width);
</pre></div>
<!-- end-of-code-block -->
</div>
<div class="section" id="example-of-convex-shape">
<h2><a class="toc-backref" href="#id6">Example of Convex Shape</a></h2>
<p>We create 10 vertices as random points at first, and convex hull is created based on these random points.</p>
<div class="highlight"><pre>Vector2[] test_point = new Vector2[10];

for (int i = 0; i &lt; 10; i++)
{
        test_point[i] = new Vector2(rand_gen.Next(-1000, 1000), rand_gen.Next(-1000, 1000)) * 2.0f / 1000.0f;
}

sceneShapes[4] = PhysicsShape.CreateConvexHull(test_point, 10);
</pre></div>
<!-- end-of-code-block -->
<p>CreateConvexHull creates convex hull from several random points here.</p>
</div>
<div class="section" id="number-of-collision-shapes">
<h2><a class="toc-backref" href="#id7">Number of Collision Shapes</a></h2>
<p>We can increment one by one for each collision shapes, but we set numShape after all collision shapes are registered here.</p>
<div class="highlight"><pre>numShape = 5;
</pre></div>
<!-- end-of-code-block -->
<div class="line-block">
<div class="line">All things of registration of collision shapes for PrimitiveScene are done here.</div>
<div class="line"><br /></div>
<div class="line">But these are only for registration of collision shapes and it does not say that there are rigid bodies.</div>
<div class="line">Next we will create rigid bodies based on registered collision shapes.</div>
<div class="line"><br /></div>
</div>
</div>
</div>
<div class="section" id="create-the-rigid-body-linked-with-the-collision-shape">
<h1><a class="toc-backref" href="#id8">Create the rigid body linked with the collision shape</a></h1>
<p>There are several types for rigid bodies.</p>
<div class="section" id="dynamic-rigid-body">
<h2><a class="toc-backref" href="#id9">Dynamic Rigid Body</a></h2>
<ul class="simple">
<li>Usual rigid body used well</li>
<li>Has velocity and acceleration and move in a scene</li>
</ul>
</div>
<div class="section" id="static-rigid-body">
<h2><a class="toc-backref" href="#id10">Static Rigid Body</a></h2>
<ul class="simple">
<li>Does not move at all from the start of the scene to the end</li>
<li>Calculated assuming that it has infinite mass</li>
</ul>
</div>
<div class="section" id="kinematic-rigid-body">
<h2><a class="toc-backref" href="#id11">Kinematic Rigid Body</a></h2>
<ul class="simple">
<li>Be set to the state of rest or moved compulsorily temporarily</li>
<li>Calculated assuming that it has infinite mass temporarily</li>
</ul>
</div>
<div class="section" id="trigger-rigid-body">
<h2><a class="toc-backref" href="#id12">Trigger Rigid Body</a></h2>
<ul class="simple">
<li>Used for the purpose of detecting whether any rigid bodies having gone into a certain domain in a scene</li>
<li>Although there is collision detection, but there is not collision response</li>
</ul>
<div class="line-block">
<div class="line">First of all, it is necessary to clarify which type of rigid body we would like to create.</div>
<div class="line">Static rigid body is used when creating the wall or floor which do not move at all. On the other hand, dynamic rigid body is used when creating a ball which rolls on the floor.</div>
<div class="line"><br /></div>
<div class="line">When creating a rigid body, it is common to set the type of the above-mentioned rigid body, and to arrange initial state of it.</div>
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="attribute-used-to-initial-setting-of-a-rigid-body">
<h2><a class="toc-backref" href="#id13">Attribute Used to Initial Setting of a Rigid Body</a></h2>
<ul class="simple">
<li>Mass</li>
<li>Position</li>
<li>Rotation</li>
<li>Velocity</li>
<li>Angular Velocity</li>
</ul>
<div align="left" class="figure">
<img alt="alternate text" src="image/physics2d/rigid_body_e.png" style="width: 600.0px; height: 376.0px;" />
</div>
<div class="line-block">
<div class="line">Now we will check how rigid bodies are arranged for the initial state of PrimitiveScene.</div>
<div class="line">First of all, the rigid body used as a wall, a floor, and ceiling is created as a static rigid body in the scene.</div>
<div class="line">These rigid bodies do not move at all from the start to the end.</div>
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="example-of-setup-of-static-rigid-body">
<h2><a class="toc-backref" href="#id14">Example of Setup of Static Rigid Body</a></h2>
<div class="highlight"><pre>public override void InitScene()
{
        ...
        ...
        ...

    // Create static walls to limit the range of action of active rigid sceneBodies
    {
        // new PhysicsBody( &quot;shape of the body&quot;,  &quot;mass of the body(kg)&quot; )
        sceneBodies[numBody] = new PhysicsBody(sceneShapes[0], PhysicsUtility.FltMax);

        // Set the position &amp; the rotation
        sceneBodies[numBody].position = new Vector2(0, -wall_height.Y);
        sceneBodies[numBody].rotation = 0;

        // Make shapeIndex consistent with what we set as convex shape
        sceneBodies[numBody].shapeIndex = 0;
        numBody++;

        sceneBodies[numBody] = new PhysicsBody(sceneShapes[1], PhysicsUtility.FltMax);
        sceneBodies[numBody].position = new Vector2(wall_width.X, 0);
        sceneBodies[numBody].rotation = 0;
        sceneBodies[numBody].shapeIndex = 1;
        numBody++;

        sceneBodies[numBody] = new PhysicsBody(sceneShapes[1], PhysicsUtility.FltMax);
        sceneBodies[numBody].position = new Vector2(-wall_width.X, 0);
        sceneBodies[numBody].rotation = 0;
        sceneBodies[numBody].shapeIndex = 1;
        numBody++;

        sceneBodies[numBody] = new PhysicsBody(sceneShapes[0], PhysicsUtility.FltMax);
        sceneBodies[numBody].position = new Vector2(0, wall_height.Y);
        sceneBodies[numBody].rotation = 0;
        sceneBodies[numBody].shapeIndex = 0;
        numBody++;
    }

        ...
        ...
        ...
}
</pre></div>
<!-- end-of-code-block -->
<div class="line-block">
<div class="line"><br /></div>
<div class="line">Here, the static rigid body used as a floor is set up.</div>
</div>
<div class="highlight"><pre>sceneBodies[numBody] = new PhysicsBody(sceneShapes[0], PhysicsUtility.FltMax);
sceneBodies[numBody].position = new Vector2(0, -wall_height.Y);
sceneBodies[numBody].rotation = 0;
sceneBodies[numBody].shapeIndex = 0;
numBody++;
</pre></div>
<!-- end-of-code-block -->
<ol class="arabic simple">
<li>Box shape as collision shape sceneShape[0] and infinite mass PhysicsUtility.FltMax are given to the constructor of PhysicsBody</li>
<li>Vector2(0, -wall_height.Y) is set to position</li>
<li>0 is set to rotation</li>
<li>Index is set to shapeIndex as well as the constructor of PhysicsBody</li>
<li>Increment numBody which represents number of rigid bodies inside the scene</li>
</ol>
<div class="line-block">
<div class="line">A setup of a wall and a ceiling as the static rigid body is also the same.</div>
<div class="line"><br /></div>
<div class="line">Since the collision shape of the rigid body of a floor and a ceiling is the same here, the collision shape associated becomes the same.</div>
<div class="line">Because collision shape can be related with two or more rigid bodies, please take care not to create two or more same collision shape.</div>
<div class="line"><br /></div>
</div>
<div align="left" class="figure">
<img alt="alternate text" src="image/physics2d/collision_shape03_e.png" style="width: 600.0px; height: 317.0px;" />
</div>
<div class="line-block">
<div class="line"><br /></div>
<div class="line">Next we will create a sphere, box and convex as a dynamic rigid body which can move freely in a scene.</div>
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="example-of-setup-of-dynamic-rigid-body">
<h2><a class="toc-backref" href="#id15">Example of Setup of Dynamic Rigid Body</a></h2>
<div class="highlight"><pre>// Create dynamic rigid sceneBodies
{
    // Create a box-shaped dynamic rigid body
    {
        sceneBodies[numBody] = new PhysicsBody(sceneShapes[2], 1.0f);
        sceneBodies[numBody].position = new Vector2(-10.0f, -5.0f);
        sceneBodies[numBody].rotation = PhysicsUtility.GetRadian(30.0f);
        sceneBodies[numBody].shapeIndex = 2;
        numBody++;
    }

    // Create a sphere-shaped dynamic rigid body
    {
        sceneBodies[numBody] = new PhysicsBody(sceneShapes[3], 1.0f);
        sceneBodies[numBody].position = new Vector2(0.0f, -5.0f);
        sceneBodies[numBody].rotation = 0;
        sceneBodies[numBody].shapeIndex = 3;
        sceneBodies[numBody].colFriction = 0.01f;
        numBody++;
    }

    // Create a convex-shaped dynamic rigid body
    {
        sceneBodies[numBody] = new PhysicsBody(sceneShapes[4], 1.0f);
        sceneBodies[numBody].position = new Vector2(10.0f, -5.0f);
        sceneBodies[numBody].rotation = 0;
        sceneBodies[numBody].shapeIndex = 4;
        numBody++;
    }
}
</pre></div>
<!-- end-of-code-block -->
<p>Here the box as dynamic rigid body is set up.</p>
<div class="highlight"><pre>sceneBodies[numBody] = new PhysicsBody(sceneShapes[2], 1.0f);
sceneBodies[numBody].position = new Vector2(-10.0f, -5.0f);
sceneBodies[numBody].rotation = PhysicsUtility.GetRadian(30.0f);
sceneBodies[numBody].shapeIndex = 2;
numBody++;
</pre></div>
<!-- end-of-code-block -->
<ol class="arabic simple">
<li>Box shape as collision shape sceneShape[2] and mass 1.0f are given to the constructor of PhysicsBody</li>
<li>Vector2(-10.0f, -5.0f) is set to position</li>
<li>PhysicsUtility.GetRadian(30.0f) is set to rotation ( in radian )</li>
<li>Index is set to shapeIndex as well as the constructor of PhysicsBody</li>
<li>Increment numBody which represents number of rigid bodies inside the scene</li>
</ol>
<div class="line-block">
<div class="line">A setup of a sphere and convex as the dynamic rigid body is also the same.</div>
<div class="line"><br /></div>
<div class="line">Here the sphere as dynamic rigid body is set up.</div>
</div>
<div class="highlight"><pre>sceneBodies[numBody] = new PhysicsBody(sceneShapes[3], 1.0f);
sceneBodies[numBody].position = new Vector2(0.0f, -5.0f);
sceneBodies[numBody].rotation = 0;
sceneBodies[numBody].shapeIndex = 3;
sceneBodies[numBody].colFriction = 0.01f;
numBody++;
</pre></div>
<!-- end-of-code-block -->
<ol class="arabic simple">
<li>Box shape as collision shape sceneShape[3] and mass 1.0f are given to the constructor of PhysicsBody</li>
<li>Vector2(0.0f, -5.0f) is set to position</li>
<li>0 is set to rotation</li>
<li>Index is set to shapeIndex as well as the constructor of PhysicsBody</li>
<li>Collision Friction 0.01 is set</li>
<li>Increment numBody which represents number of rigid bodies inside the scene</li>
</ol>
<div class="line-block">
<div class="line"><br /></div>
<div class="line">Here the convex as dynamic rigid body is set up.</div>
</div>
<div class="highlight"><pre>sceneBodies[numBody] = new PhysicsBody(sceneShapes[4], 1.0f);
sceneBodies[numBody].position = new Vector2(10.0f, -5.0f);
sceneBodies[numBody].rotation = 0;
sceneBodies[numBody].shapeIndex = 4;
numBody++;
</pre></div>
<!-- end-of-code-block -->
<ol class="arabic simple">
<li>Box shape as collision shape sceneShape[4] and mass 1.0f are given to the constructor of PhysicsBody</li>
<li>Vector2(10.0f, -5.0f) is set to position</li>
<li>0 is set to rotation</li>
<li>Index is set to shapeIndex as well as the constructor of PhysicsBody</li>
<li>Increment numBody which represents number of rigid bodies inside the scene</li>
</ol>
<div class="line-block">
<div class="line">In addition, in the case of a dynamic rigid body, cautions are required for the scale of the rigid body containing mass.</div>
<div class="line"><br /></div>
</div>
<div align="left" class="figure">
<img alt="alternate text" src="image/physics2d/sim_instability_e.png" style="width: 600.0px; height: 327.0px;" />
</div>
<div class="line-block">
<div class="line">When the rigid bodies of different mass scales collide, the instability of simulation may arise.</div>
<div class="line">About the case of dynamic rigid body, it is desirable to create a rigid body in the following ranges as a rough standard.</div>
</div>
<ul class="simple">
<li>mass scale : 0.2[Kg] - 20.0[Kg]</li>
<li>length scale: 0.2[m] - 20.0[m]</li>
</ul>
<div class="line-block">
<div class="line">Next we will create the kinematic rigid body which is stopped compulsorily temporarily.</div>
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="example-of-setup-of-kinematic-rigid-body">
<h2><a class="toc-backref" href="#id16">Example of Setup of Kinematic Rigid Body</a></h2>
<div class="highlight"><pre> // Create a kinematic rigid body whose shape is box
{
    sceneBodies[numBody] = new PhysicsBody(sceneShapes[2], 1.0f);
    sceneBodies[numBody].position = new Vector2(-10.0f, 15.0f);
    sceneBodies[numBody].rotation = PhysicsUtility.GetRadian(30.0f);
    sceneBodies[numBody].shapeIndex = 2;
    sceneBodies[numBody].SetBodyKinematic();
    index0 = numBody++;
}

// Create a sphere-shaped kinematic rigid body
{
    sceneBodies[numBody] = new PhysicsBody(sceneShapes[3], 1.0f);
    sceneBodies[numBody].position = new Vector2(0.0f, 15.0f);
    sceneBodies[numBody].rotation = 0;
    sceneBodies[numBody].shapeIndex = 3;
    sceneBodies[numBody].colFriction = 0.01f;
    sceneBodies[numBody].SetBodyKinematic();
    index1 = numBody++;
}

// Create a convex-shaped kinematic rigid body
{
    sceneBodies[numBody] = new PhysicsBody(sceneShapes[4], 1.0f);
    sceneBodies[numBody].position = new Vector2(10.0f, 15.0f);
    sceneBodies[numBody].rotation = 0;
    sceneBodies[numBody].shapeIndex = 4;
    sceneBodies[numBody].SetBodyKinematic();
    index2 = numBody++;
}
</pre></div>
<!-- end-of-code-block -->
<div class="line-block">
<div class="line">Although the kinematic rigid body used as a box is set up here, it is the procedure almost same as a setup of a dynamic rigid body.</div>
<div class="line">A difference is a portion which calls SetBodyKinematic().</div>
</div>
<div class="highlight"><pre>sceneBodies[numBody] = new PhysicsBody(sceneShapes[2], 1.0f);
sceneBodies[numBody].position = new Vector2(-10.0f, 15.0f);
sceneBodies[numBody].rotation = PhysicsUtility.GetRadian(30.0f);
sceneBodies[numBody].shapeIndex = 2;
sceneBodies[numBody].SetBodyKinematic();
index0 = numBody++;
</pre></div>
<!-- end-of-code-block -->
<ol class="arabic simple">
<li>Box shape as collision shape sceneShape[2] and mass 1.0f are given to the constructor of PhysicsBody</li>
<li>Vector2(-10.0f, 15.0f) is set to position</li>
<li>PhysicsUtility.GetRadian(30.0f) is set to rotation (in radian)</li>
<li>Index is set to shapeIndex as well as the constructor of PhysicsBody</li>
<li>Call SetBodyKinematic() to change for the kinematic rigid body and necessary information set as the dynamic rigid body are stored</li>
<li>Increment numBody which represents number of rigid bodies inside the scene</li>
</ol>
<div class="line-block">
<div class="line">A setup of a sphere and a convex as the kinematic rigid body is also the same.</div>
<div class="line"><br /></div>
<div class="line">In addition, it can be returned to original dynamic rigid body (stored necessary information) is possible for kinematic rigid body.</div>
<div class="line"><br /></div>
<div class="line">In PrimitiveScene, the rigid body once set as the kinematic rigid body by a button input is returned to a dynamic rigid body, or it is again changed to the kinematic rigid body.</div>
<div class="line">This is why index0 is saved for the kinematic rigid body setting.</div>
<div class="line"><br /></div>
</div>
<div class="highlight"><pre>// Game controller handling
public override void KeyboradFunc(GamePadButtons button)
{
    switch (button)
    {
        case GamePadButtons.Square:

                //
            // isKinematicOrStatic() checks the mass of the rigid body and determines whether a body is kinematic or static
            // backToDynamic() cannot be called for rigid sceneBodies not set up with setKinematic()
            //

            if (sceneBodies[index0].IsKinematic())
                sceneBodies[index0].BackToDynamic();
            else
                sceneBodies[index0].SetBodyKinematic();

            if (sceneBodies[index1].IsKinematic())
                sceneBodies[index1].BackToDynamic();
            else
                sceneBodies[index1].SetBodyKinematic();

            if (sceneBodies[index2].IsKinematic())
                sceneBodies[index2].BackToDynamic();
            else
                sceneBodies[index2].SetBodyKinematic();

            break;
        default:
            break;
    }
}
</pre></div>
<!-- end-of-code-block -->
<div class="line-block">
<div class="line">It checks whether a rigid body is a kinematic rigid body by IsKinematic API, and if it is a kinematic rigid body, the stored information is returned and it is made to change to a dynamic rigid body.</div>
<div class="line">Also in order to return the stored information, it is necessary to set a kinematic rigid body as a dynamic rigid body at first.</div>
<div class="line">Please set up the rigid body as a static rigid body from the beginning if it will not be changed to a dynamic rigid body.</div>
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="characteristic-of-the-scene-setup">
<h2><a class="toc-backref" href="#id17">Characteristic of the Scene Setup</a></h2>
<p>We checked the initial arrangement of a rigid body in InitScene().
Next we will see setup of the characteristic of the scene used by InitScene().</p>
<div class="highlight"><pre>public override void InitScene ()
{
        // Create an empty simulation scene
        base.InitScene();
        sceneName = &quot;PrimitiveScene&quot;;

        // Set the restitution coefficient a bit stronger
        this.restitutionCoeff = 0.8f;
</pre></div>
<!-- end-of-code-block -->
<p>sceneName contains the string which represents the name of scene, and it is set as &quot;PrimitiveScene&quot;.</p>
<div class="highlight"><pre>this.restitutionCoeff = 0.8f;
</pre></div>
<!-- end-of-code-block -->
<p>The coefficient of rebound to rebounding which is the characteristic of a scene is set up, and rebounding is set as the scene which arises exactly.</p>
<p>The following values can be set up as a parameter which determines the characteristic of a collision within a scene.</p>
<ul class="simple">
<li>float penetrationRepulse (default 0.2f) ... Acceleration factor of the restitution to the penetration of collision</li>
<li>float penetLimit (default 0.03f) ... Tolerance to the penetration of collision</li>
<li>float tangentFriction (default 0.3f) ... Coefficient of friction of the tangential adjusting to rebounding</li>
<li>float restitutionCoeff (default 0.0f) ... Coefficient of rebound to rebounding</li>
</ul>
<div align="left" class="figure">
<img alt="alternate text" src="image/physics2d/scene_prop_e.png" style="width: 600.0px; height: 346.0px;" />
</div>
<div class="line-block">
<div class="line">By changing these values, it is possible to become a scene which rebounding tends to carry out, to become a scene which rebounding cannot carry out easily, or to make it a scene without friction.</div>
<div class="line">There is a sample &quot;sample/Physics2D/Physics2DSample/TutorialScene/ScenePropertyScene.cs&quot;, please refer it.</div>
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="sleep-of-rigid-body">
<h2><a class="toc-backref" href="#id18">Sleep of Rigid Body</a></h2>
<div class="line-block">
<div class="line"><br /></div>
<div class="line">In order to reduce simulation cost, when the rigid body is in the state where it can be considered that it is not moving mostly but is still standing, a rigid body goes into a sleep state.</div>
<div class="line">When a rigid body is in sleep status, collision detection and collision response for it will be ignored and not treated.</div>
<div class="line"><br /></div>
<div class="line">In PrimitiveScene, collision between the floor and the rigid body in contact with its floor will not be treated for sleep status.</div>
<div class="line">However, when a new collision occurs and velocity is produced, it makes a rigid body wake up from sleep state.</div>
<div class="line"><br /></div>
</div>
<div align="left" class="figure">
<img alt="alternate text" src="image/physics2d/sleep_status_e.png" style="width: 600.0px; height: 327.0px;" />
</div>
<div class="line-block">
<div class="line">In addition, when it is a state of rest compulsorily because of the static rigid body or the kinematic rigid body, it is always considered as a sleep state.</div>
<div class="line"><br /></div>
</div>
</div>
</div>
<div class="section" id="rendering-of-rigid-body">
<h1><a class="toc-backref" href="#id19">Rendering of Rigid Body</a></h1>
<div class="line-block">
<div class="line">Rendering of rigid body is explained shortly. About rendering itself, please refer the documentation of Graphics samples.</div>
<div class="line">Here we will just check parts which are related to Physics2D.</div>
<div class="line"><br /></div>
<div class="line">Generally, rendering of a rigid body is done based on the collision shape set to the rigid body.</div>
<div class="line">As mentioned already, collision shape is registered to sceneShapes. And sceneShapes is array of PhsyicsShape.</div>
<div class="line"><br /></div>
</div>
<div class="section" id="preparation-of-vertex-buffer">
<h2><a class="toc-backref" href="#id20">Preparation of Vertex Buffer</a></h2>
<p>First of all, vertex buffer given to shader program is required.</p>
<div class="highlight"><pre>public class PrimitiveScene : PhysicsScene
{
    // Vertex Buffer for Body Rendering
    private VertexBuffer[] vertices = new VertexBuffer[100];
</pre></div>
<!-- end-of-code-block -->
<div class="line-block">
<div class="line">Though the number of collision shapes does not exceed one hundred for PrimitiveScene、we will define vertex buffer for one hundred collision shapes as a temporal here.</div>
<div class="line">Vertex buffer can be shared rigid bodies which have the same collision shape and it is not necessary to prepare for each rigid bodies.</div>
<div class="line">This is just for PrimitiveScene, and it may be necessary to prepare vertex buffer for each rigid bodies in the case that texture mapping is used for rendering rigid bodies.</div>
<div class="line"><br /></div>
<div class="line">In the next, we will create vertex buffer by giving number and format of vertices.</div>
</div>
<div class="highlight"><pre>public PrimitiveScene()
{
    // Simulation Scene Set Up
    InitScene();

    // Setup for Rendering Object
    for (int i = 0; i &lt; numShape; i++)
    {
        if (sceneShapes[i].numVert == 0)
        {
            vertices[i] = new VertexBuffer(37, VertexFormat.Float3);
        }
        else
        {
            vertices[i] = new VertexBuffer(sceneShapes[i].numVert + 1, VertexFormat.Float3);
        }
</pre></div>
<!-- end-of-code-block -->
</div>
<div class="section" id="structure-of-collision-shape-physicsshape">
<h2><a class="toc-backref" href="#id21">Structure of Collision Shape PhysicsShape</a></h2>
<p>Here we will check the structure of PhysicsShape.</p>
<div class="highlight"><pre>public partial class PhysicsShape
{
    public int numVert;

    public Vector2[] vertList = new Vector2[30];
        ...
        ...
        ...
}
</pre></div>
<!-- end-of-code-block -->
<div class="line-block">
<div class="line">Although this is a part of definition, PhysicsShape holds numVert which represents the number of vertices, and vertList which actually saves a vertex sequence.</div>
<div class="line">Although rendering should be done based on this definition, in the case of numVert==0, it is setting of the sphere, and cautions are required for the point that the radius is set as vertList[0].X.</div>
</div>
<div align="left" class="figure">
<img alt="alternate text" src="image/physics2d/physics_render_e.png" style="width: 600.0px; height: 330.0px;" />
</div>
<p>This is the setting of vertices for vertex buffer based on the definition of PhysicsShape.</p>
<div class="highlight"><pre>// Line Rendering for Object
private void MakeLineListConvex(PhysicsShape con, VertexBuffer vertices)
{

    if (con.numVert == 0)
    {
        float[] vertex = new float[3 * 37];

        int i = 0;
        float rad = con.vertList[0].X;

        for (float th1 = 0.0f; th1 &lt; 360.0f; th1 = th1 + 10.0f)
        {
            float th1_rad = th1 / 180.0f * PhysicsUtility.Pi;

            float x1 = rad * (float)Math.Cos(th1_rad);
            float y1 = rad * (float)Math.Sin(th1_rad);

            vertex[3 * i + 0] = x1;
            vertex[3 * i + 1] = y1;
            vertex[3 * 　i + 2] = 0.0f;
            i++;
        }

        vertex[3 * i + 0] = vertex[3 * 0 + 0];
        vertex[3 * i + 1] = vertex[3 * 0 + 1];
        vertex[3 * i + 2] = vertex[3 * 0 + 2];

        vertices.SetVertices(0, vertex);

    }
    else
    {
        float[] vertex = new float[3 * (con.numVert + 1)];

        int i;

        for (i = 0; i &lt; con.numVert; i++)
        {
            Vector2 v1;
            v1 = con.vertList[i];

            vertex[3 * i + 0] = v1.X;
            vertex[3 * i + 1] = v1.Y;
            vertex[3 * i + 2] = 0.0f;
        }

        vertex[3 * i + 0] = vertex[3 * 0 + 0];
        vertex[3 * i + 1] = vertex[3 * 0 + 1];
        vertex[3 * i + 2] = vertex[3 * 0 + 2];

        vertices.SetVertices(0, vertex);
    }
}
</pre></div>
<!-- end-of-code-block -->
<div class="line-block">
<div class="line">We divide cases into the case of con.numVert == 0 and others.</div>
<div class="line">This is because information is held in the special format in the case of the sphere as stated.</div>
<div class="line">In the case of a sphere, since only the information on a radius is saved inside the PhysicsShape instance, we have to generate the vertex sequence for rendering by ourself.</div>
<div class="line">Then, a vertex sequence is made from taking up a number of points on the circumference based on this radius.</div>
<div class="line">Here vertices are generated on 36 vertices of the 10-degree unit from 0 degree to 350 degrees, and the coordinates same at the last as the first vertex, it becomes a total of 37 vertices.</div>
<div class="line"><br /></div>
<div class="line">On the other hand, for box or general convex, the vertex sequence currently held at the PhysicsShape instance is set to a vertex buffer.</div>
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="acquisition-of-vertex-data-in-the-case-of-sphere">
<h2><a class="toc-backref" href="#id22">Acquisition of Vertex Data in The Case of Sphere</a></h2>
<div class="highlight"><pre>if (con.numVert == 0)
{
    float[] vertex = new float[3 * 37];

    int i = 0;
    float rad = con.vertList[0].X;

    for (float th1 = 0.0f; th1 &lt; 360.0f; th1 = th1 + 10.0f)
    {
        float th1_rad = th1 / 180.0f * PhysicsUtility.Pi;

        float x1 = rad * (float)Math.Cos(th1_rad);
        float y1 = rad * (float)Math.Sin(th1_rad);

        vertex[3 * i + 0] = x1;
        vertex[3 * i + 1] = y1;
        vertex[3 * i + 2] = 0.0f;
        i++;
    }

    vertex[3 * i + 0] = vertex[3 * 0 + 0];
    vertex[3 * i + 1] = vertex[3 * 0 + 1];
    vertex[3 * i + 2] = vertex[3 * 0 + 2];

    vertices.SetVertices(0, vertex);

}
</pre></div>
<!-- end-of-code-block -->
<div class="line-block">
<div class="line">Although the buffer of vertices used for drawing has three-dimensional coordinates, since the direction of Z-axis is disregarded, 0.0 f is always specified as the Z coordinate.</div>
<div class="line">In order to render lines, the coordinates same as the last vertex as the first vertex are given.</div>
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="acquisition-of-vertex-data-in-the-case-of-box-or-general-convex">
<h2><a class="toc-backref" href="#id23">Acquisition of Vertex Data in The Case of Box or General Convex</a></h2>
<div class="highlight"><pre>else
{
    float[] vertex = new float[3 * (con.numVert + 1)];

    int i;

    for (i = 0; i &lt; con.numVert; i++)
    {
        Vector2 v1;
        v1 = con.vertList[i];

        vertex[3 * i + 0] = v1.X;
        vertex[3 * i + 1] = v1.Y;
        vertex[3 * i + 2] = 0.0f;
    }

    vertex[3 * i + 0] = vertex[3 * 0 + 0];
    vertex[3 * i + 1] = vertex[3 * 0 + 1];
    vertex[3 * i + 2] = vertex[3 * 0 + 2];

    vertices.SetVertices(0, vertex);
}
</pre></div>
<!-- end-of-code-block -->
<p>In order to render lines, the coordinates same as the last vertex as the first vertex are given.</p>
</div>
<div class="section" id="rendering-of-shape-of-rigid-bodies">
<h2><a class="toc-backref" href="#id24">Rendering of shape of rigid bodies</a></h2>
<div class="line-block">
<div class="line"><br /></div>
<div class="line">It is necessary for rendering of an actual scene not only to to render shape, but to render it according to change of the position in each frame of a rigid body's position or rotation.</div>
<div class="line">Therefore, it is necessary using the value of position, rotation, localPosition, and localRotation of a rigid body to set up the conversion matrix used for rendering.</div>
<div class="line">This matrix is a matrix for changing into the vertex sequence which actually reflected the position of a rigid body, the angle, etc. from the vertex sequence which shows the shape of a basis.</div>
<div class="line">If it is not the case of compound, localPosition and localRotation can be ignored by considering only position and rotation.</div>
<div class="line"><br /></div>
</div>
<div align="left" class="figure">
<img alt="alternate text" src="image/physics2d/rigid_body_e.png" style="width: 600.0px; height: 376.0px;" />
</div>
<div class="highlight"><pre>// Draw objects
public override void DrawAllBody(ref GraphicsContext graphics, ref ShaderProgram program, Matrix4 renderMatrix, int click_index)
{
    for (int j = 0; j &lt; numShape; j++)
    {
        graphics.SetVertexBuffer(0, vertices[j]);

        for (int i = 0; i &lt; numBody; i++)
        {
            uint index = sceneBodies[i].shapeIndex;

            if (j != index) continue;

            Matrix4 rotationMatrix = Matrix4.RotationZ(sceneBodies[i].rotation);

            Matrix4 transMatrix = Matrix4.Translation(
                new Vector3(sceneBodies[i].position.X, sceneBodies[i].position.Y, 0.0f));

            Matrix4 local_rotationMatrix = Matrix4.RotationZ(sceneBodies[i].localRotation);

            Matrix4 local_transMatrix = Matrix4.Translation(
                new Vector3(sceneBodies[i].localPosition.X, sceneBodies[i].localPosition.Y, 0.0f));

            Matrix4 WorldMatrix = renderMatrix * transMatrix * rotationMatrix * local_transMatrix * local_rotationMatrix;

            program.SetUniformValue(0, ref WorldMatrix);

            if (i == click_index)
            {
                Vector3 color = new Vector3(1.0f, 0.0f, 0.0f);
                program.SetUniformValue(1, ref color);
            }
            else
            {
                Vector3 color = new Vector3(0.0f, 1.0f, 1.0f);
                program.SetUniformValue(1, ref color);
            }

            if (sceneShapes[index].numVert == 0)
                graphics.DrawArrays(DrawMode.LineStrip, 0, 37);
            else
                graphics.DrawArrays(DrawMode.LineStrip, 0, sceneShapes[index].numVert + 1);

        }

    }
}
</pre></div>
<!-- end-of-code-block -->
<div class="line-block">
<div class="line">We will check the code in order.</div>
<div class="line">First half contains a setup of the world matrix for a setup of a shader program, or a view matrix.</div>
<div class="line">Please refer Graphics sample for setting of a shader program.</div>
<div class="line"><br /></div>
</div>
<div class="highlight"><pre>Matrix4 rotationMatrix = Matrix4.RotationZ(sceneBodies[i].rotation);

Matrix4 transMatrix = Matrix4.Translation(
    new Vector3(sceneBodies[i].position.X, sceneBodies[i].position.Y, 0.0f));

Matrix4 local_rotationMatrix = Matrix4.RotationZ(sceneBodies[i].localRotation);

Matrix4 local_transMatrix = Matrix4.Translation(
    new Vector3(sceneBodies[i].localPosition.X, sceneBodies[i].localPosition.Y, 0.0f));

Matrix4 WorldMatrix = renderMatrix * transMatrix * rotationMatrix * local_transMatrix * local_rotationMatrix;

program.SetUniformValue(0, ref WorldMatrix);
</pre></div>
<!-- end-of-code-block -->
<div class="line-block">
<div class="line">Above matrix calculation uses (transMatrix * rotationMatrix * local_transMatrix * local_rotationMatrix).</div>
<div class="line">If it is not the case of compound, it is enough to consider only (transMatrix * rotationMatrix).</div>
<div class="line"><br /></div>
<div class="line">Multiplication will be performed in order of the following and each original vertex of the collision shape set as the rigid body in drawing will be changed into the vertex reflecting a current position, an rotation, etc. of the rigid body.</div>
</div>
<ol class="arabic simple">
<li>local_rotationMatrix</li>
<li>local_transMatrix</li>
<li>rotationMatrix</li>
<li>transMatrix</li>
</ol>
<p>When setting up the matrix of conversion, the rest should just render by giving the vertex of the original collision shape to shader.</p>
<div class="highlight"><pre>if (sceneShapes[index].numVert == 0)
    graphics.DrawArrays(DrawMode.LineStrip, 0, 37);
else
    graphics.DrawArrays(DrawMode.LineStrip, 0, sceneShapes[index].numVert + 1);
</pre></div>
<!-- end-of-code-block -->
</div>
</div>
<div class="section" id="rendering-of-debug-information">
<h1><a class="toc-backref" href="#id25">Rendering of Debug Information</a></h1>
<div class="line-block">
<div class="line">The position information on a colliding point is well used to debug rendering.</div>
<div class="line">The information on the bounding box of a rigid body or joint between two rigid bodies is well used for others to debug rendering.</div>
<div class="line"><br /></div>
</div>
<div class="section" id="debug-rendering-of-collision-point">
<h2><a class="toc-backref" href="#id26">Debug Rendering of Collision Point</a></h2>
<div align="left" class="figure">
<img alt="alternate text" src="image/physics2d/coll_info_e.png" style="width: 600.0px; height: 361.0px;" />
</div>
<div class="line-block">
<div class="line"><br /></div>
<div class="line">When it is in the state where the rigid body A and the rigid body B have collided, the information on a colliding point is generated by each of the rigid body A and the rigid body B.</div>
<div class="line">Usually, although the position coordinate of the collision data of the rigid body A and the rigid body B is almost the same,</div>
<div class="line">when a penetration arises between the rigid body A and the rigid body B by strong external force etc. for a moment,</div>
<div class="line-block">
<div class="line">a gap arises in the position coordinate of the collision data over the rigid body A and the rigid body B.</div>
<div class="line"><br /></div>
</div>
<div class="line">Now we will look at the actual code.</div>
<div class="line">First of all, a small square is set to the vertex buffer of debug rendering in order to render a colliding point.</div>
<div class="line"><br /></div>
</div>
<div class="highlight"><pre>public class PrimitiveScene : PhysicsScene
    {
            ...
            ...
            ...

    private VertexBuffer colVert = null;

            ...
            ...
            ...


    public PrimitiveScene()
    {

            ...
            ...
            ...

        // VertexBuffer for contact points debug rendering
        {
            colVert = new VertexBuffer(4, VertexFormat.Float3);

            const float scale = 0.2f;

            float[] vertex = new float[]
            {
                -1.0f, -1.0f, 0.0f,
                1.0f, -1.0f, 0.0f,
                1.0f, 1.0f, 0.0f,
                -1.0f, 1.0f, 0.0f
            };

            for (int i = 0; i &lt; 12; i++)
                vertex[i] = vertex[i] * scale;

            colVert.SetVertices(0, vertex);
        }
</pre></div>
<!-- end-of-code-block -->
<div class="line-block">
<div class="line">Although it is good not to be a square as for the object for rendering colliding point, because simple information may be sufficient here, it is set as the square.</div>
</div>
<div class="highlight"><pre>// Debug rendering for contact points(RigidBody A &lt;=&gt; RigidBody B) and AABB(Axis Aligned Bounding Box)
public override void DrawAdditionalInfo(ref GraphicsContext graphics, ref ShaderProgram program, Matrix4 renderMatrix)
{
    // Draw contact points
    graphics.SetVertexBuffer(0, colVert);

    for (uint i = 0; i &lt; numPhysicsSolverPair; i++)
    {
        // Collision point for RigidBody A
        {
            Matrix4 transMatrix = Matrix4.Translation(
                new Vector3(solverPair[i].resA.X, solverPair[i].resA.Y, 0.0f));

            Matrix4 WorldMatrix = renderMatrix * transMatrix;
            program.SetUniformValue(0, ref WorldMatrix);

            Vector3 color = new Vector3(1.0f, 0.0f, 0.0f);
            program.SetUniformValue(1, ref color);

            graphics.DrawArrays(DrawMode.TriangleFan, 0, 4);
        }

        // Collision point for RigidBody B
        {
            Matrix4 transMatrix = Matrix4.Translation(
                new Vector3(solverPair[i].resB.X, solverPair[i].resB.Y, 0.0f));

            Matrix4 WorldMatrix = renderMatrix * transMatrix;
            program.SetUniformValue(0, ref WorldMatrix);

            Vector3 color = new Vector3(1.0f, 0.0f, 0.0f);
            program.SetUniformValue(1, ref color);

            graphics.DrawArrays(DrawMode.TriangleFan, 0, 4);
        }
    }
</pre></div>
<!-- end-of-code-block -->
<div class="line-block">
<div class="line">Since the number of the colliding points in a scene is saved at numPhysicsSolverPair and a colliding point is saved in solverPair array, only the number of times of numPhysicsSolverPair performs rendering processing of a colliding point in order.</div>
<div class="line"><br /></div>
<div class="line">The position of the colliding point by the side of the rigid body A in collision data is acquired by the following.</div>
<div class="line"><br /></div>
</div>
<div class="highlight"><pre>Matrix4 transMatrix = Matrix4.Translation(
    new Vector3(solverPair[i].resA.X, solverPair[i].resA.Y, 0.0f));
</pre></div>
<!-- end-of-code-block -->
<div class="line-block">
<div class="line">The position of the colliding point by the side of the rigid body B in collision data is acquired by the following.</div>
</div>
<div class="highlight"><pre>Matrix4 transMatrix = Matrix4.Translation(
    new Vector3(solverPair[i].resB.X, solverPair[i].resB.Y, 0.0f));
</pre></div>
<!-- end-of-code-block -->
</div>
<div class="section" id="debug-rendering-of-bounding-box">
<h2><a class="toc-backref" href="#id27">Debug Rendering of Bounding Box</a></h2>
<div class="line-block">
<div class="line"><br /></div>
<div class="line">Next we will check the portion which is carrying out debug rendering of the bounding box information.</div>
<div class="line">A bounding box is parallel to the X-axis and the Y-axis, and it is a thing of the minimum box which wraps a rigid body.</div>
</div>
<div align="left" class="figure">
<img alt="alternate text" src="image/physics2d/bounding_box_e.png" style="width: 600.0px; height: 313.0px;" />
</div>
<div class="line-block">
<div class="line">The vertex buffer for rendering a bounding box is first prepared like collision information rendering.</div>
</div>
<div class="highlight"><pre>public class PrimitiveScene : PhysicsScene
    {
            ...
            ...
            ...

    private VertexBuffer aabbVert = null;

            ...
            ...
            ...

    public PrimitiveScene()
    {

            ...
            ...
            ...

        // VertexBuffer for AABB debug rendering
        {
            aabbVert = new VertexBuffer(5, VertexFormat.Float3);

            float[] vertex = new float[]
            {
                0.0f, 0.0f, 0.0f,
                1.0f, 0.0f, 0.0f,
                1.0f, 1.0f, 0.0f,
                0.0f, 1.0f, 0.0f,
                0.0f, 0.0f, 0.0f,
            };

            aabbVert.SetVertices(0, vertex);
        }
</pre></div>
<!-- end-of-code-block -->
<div class="line-block">
<div class="line"><br /></div>
<div class="line">The bounding box is prepared five points as the vertex, in order to perform line rendering, and it makes the last vertex as well as the first vertex.</div>
<div class="line"><br /></div>
</div>
<div class="highlight"><pre>// Debug rendering for contact points(RigidBody A &lt;=&gt; RigidBody B) and AABB(Axis Aligned Bounding Box)
public override void DrawAdditionalInfo(ref GraphicsContext graphics, ref ShaderProgram program, Matrix4 renderMatrix)
{

        ...
        ...
        ...

    // Draw AABB Bounding Box
    graphics.SetVertexBuffer(0, aabbVert);

    for (uint i = 0; i &lt; numBody; i++)
    {

        Matrix4 scaleMatrix = new Matrix4(
             sceneBodies[i].aabbMax.X - sceneBodies[i].aabbMin.X, 0.0f, 0.0f, 0.0f,
             0.0f, sceneBodies[i].aabbMax.Y - sceneBodies[i].aabbMin.Y, 0.0f, 0.0f,
             0.0f, 0.0f, 1.0f, 0.0f,
             0.0f, 0.0f, 0.0f, 1.0f
         );

        Matrix4 transMatrix = Matrix4.Translation(
            new Vector3(sceneBodies[i].aabbMin.X, sceneBodies[i].aabbMin.Y, 0.0f));

        Matrix4 WorldMatrix = renderMatrix * transMatrix * scaleMatrix;
        program.SetUniformValue(0, ref WorldMatrix);

        Vector3 color = new Vector3(1.0f, 1.0f, 0.0f);
        program.SetUniformValue(1, ref color);

        graphics.DrawArrays(DrawMode.LineStrip, 0, 5);
    }
</pre></div>
<!-- end-of-code-block -->
<div class="line-block">
<div class="line">The size and position of a bounding box change with a rigid body.</div>
<div class="line">The angle of a bounding box is not based on a rigid body, but always becomes parallel to the X-axis and the Y-axis.</div>
<div class="line">Since the state of the rigid body is saved in sceneBodies array and the information on the size of a bounding box is saved at the value of aabbMax and aabbMin, it renders using it.</div>
</div>
<p>Acquisition of the size of a bounding box</p>
<div class="highlight"><pre>Matrix4 scaleMatrix = new Matrix4(
     sceneBodies[i].aabbMax.X - sceneBodies[i].aabbMin.X, 0.0f, 0.0f, 0.0f,
     0.0f, sceneBodies[i].aabbMax.Y - sceneBodies[i].aabbMin.Y, 0.0f, 0.0f,
     0.0f, 0.0f, 1.0f, 0.0f,
     0.0f, 0.0f, 0.0f, 1.0f
 );
</pre></div>
<!-- end-of-code-block -->
<p>Acquisition of the position of a bounding box</p>
<div class="highlight"><pre>Matrix4 transMatrix = Matrix4.Translation(
    new Vector3(sceneBodies[i].aabbMin.X, sceneBodies[i].aabbMin.Y, 0.0f));
</pre></div>
<!-- end-of-code-block -->
<p>After adjusting the size of a bounding box, in order to render in the right position, the matrix for rendering is set up in the following turn.</p>
<ol class="arabic simple">
<li>scaleMatrix</li>
<li>transMatrix</li>
</ol>
<div class="highlight"><pre>Matrix4 WorldMatrix = renderMatrix * transMatrix * scaleMatrix;
</pre></div>
<!-- end-of-code-block -->
<div class="line-block">
<div class="line">In addition, resources, such as a vertex buffer prepared for these debug rendering, should  be required to release</div>
<div class="line">at the time of the end of a scene, or a change, and should make it removed.</div>
<div class="line"><br /></div>
<div class="line">Below in PrimitiveScene, the vertex buffer for rigid body rendering and the vertex buffer for debugging information rendering are released.</div>
</div>
<div class="highlight"><pre>public override void ReleaseScene()
{
    for (int i = 0; i &lt; numShape; i++)
        if(vertices[i] != null)
            vertices[i].Dispose();

    if(aabbVert != null) aabbVert.Dispose();
    if(colVert != null) colVert.Dispose();
}
</pre></div>
<!-- end-of-code-block -->
<div class="line-block">
<div class="line"><br /></div>
<div class="line">Although the outline of PrimitiveScene has been seen above, we recommend you to attempt how for a result to change on modifying actually various values.</div>
</div>
<div class="section" id="features-of-2-dimensional-physics-simulation-physics2d-library">
<h3><a class="toc-backref" href="#id28">Features of 2-Dimensional Physics Simulation Physics2D Library</a></h3>
</div>
</div>
</div>
<div class="section" id="joint-setting">
<h1><a class="toc-backref" href="#id29">Joint Setting</a></h1>
<div class="line-block">
<div class="line">The sample scene JointScene is seen as an example of a setup of joint.</div>
<div class="line">&quot;sample/Physics2D/Physics2DSample/BasicScene/JointScene.cs&quot;</div>
<div class="line"><br /></div>
<div class="line">Joint is the constraint set up between two rigid bodies.</div>
<div class="line">There are constraint of position and rotation for the joint between two rigid bodies.</div>
</div>
<ol class="arabic simple">
<li>Constraint of Rotation（Rotation Free, Fixed, Limited）</li>
<li>Constraint of Position (Position Free, Fixed, Limited)</li>
</ol>
<div class="line-block">
<div class="line">In addition, the joint between a static rigid body and a static rigid body do not have any meanings and we should take care not to set up those joints.</div>
</div>
<div align="left" class="figure">
<img alt="alternate text" src="image/physics2d/joint_anchor_e.png" style="width: 600.0px; height: 376.0px;" />
</div>
<div class="line-block">
<div class="line">In joint connection, a setup of the anchor point of at which point to connect a rigid body and a rigid body,</div>
<div class="line">specification of a constration of rotation and position are required.</div>
</div>
<div align="left" class="figure">
<img alt="alternate text" src="image/physics2d/joint_rot_pos_e.png" style="width: 600.0px; height: 341.0px;" />
</div>
<p>For the rigid body A and the rigid body B which were combined at joint center on an anchor point in the constraint of rotation.</p>
<ul class="simple">
<li>Free for rotation</li>
<li>Fixed for rotation</li>
<li>Limited for rotation</li>
</ul>
<p>can be set.</p>
<div align="left" class="figure">
<img alt="alternate text" src="image/physics2d/joint_rot_e.png" style="width: 600.0px; height: 331.0px;" />
</div>
<p>For the rigid body A and the rigid body B which were combined at joint center on an anchor point in the constraint of position</p>
<ul class="simple">
<li>Free for position</li>
<li>Fixed for position</li>
<li>Limited for position</li>
</ul>
<p>can be set.</p>
<div align="left" class="figure">
<img alt="alternate text" src="image/physics2d/joint_pos_e.png" style="width: 600.0px; height: 333.0px;" />
</div>
<div class="line-block">
<div class="line">For the constraint of position, two axes which go mutually are necessary.</div>
<div class="line">Usually, it is although it specifies to the X-axis and the Y-axis, even if it is not the X-axis and the Y-axis,</div>
<div class="line">as far as it is two axes which go direct mutually, it can set up. For example, Vector2(1, 1) and Vector2(-1, 1)</div>
</div>
<div align="left" class="figure">
<img alt="alternate text" src="image/physics2d/joint_axis_e.png" style="width: 600.0px; height: 340.0px;" />
</div>
<div class="section" id="fixed-both-for-rotation-and-position">
<h2><a class="toc-backref" href="#id30">Fixed both for rotation and position</a></h2>
<div class="highlight"><pre>public override void InitScene ()
{

        ...
        ...
        ...

        // Link a box rigid body to the scene with a fixed joint.
        // If you just want to fix a rigid body to the scene perfectly, it is best simply making a static rigidbody.
        {
                sceneBodies[numBody] = new PhysicsBody(sceneShapes[2], 10.0f);
                sceneBodies[numBody].position = new Vector2(-30.0f, 0.0f);
                sceneBodies[numBody].shapeIndex = 2;
                numBody++;

                PhysicsBody b1 = sceneBodies[0];
                PhysicsBody b2 = sceneBodies[numBody-1];
                sceneJoints[numJoint] = new PhysicsJoint(b1, b2, (b2.position), 0, (uint)numBody-1);
                sceneJoints[numJoint].axis1Lim = new Vector2(1, 0);
                sceneJoints[numJoint].axis2Lim = new Vector2(0, 1);
                sceneJoints[numJoint].angleLim = 1;
                numJoint++;
        }
</pre></div>
<!-- end-of-code-block -->
<div class="line-block">
<div class="line">A joint constraint is generated between the 0th rigid body and the (numBody-1)th rigid body here.</div>
<div class="line">The 0th rigid body is a static rigid body of the floor in a scene.</div>
<div class="line"><br /></div>
<div class="line">As the generation method of joint constraint, specification of the rigid body pair which makes joint, and specification of an anchor point are needed.</div>
</div>
<div class="highlight"><pre>PhysicsBody b1 = sceneBodies[0];
PhysicsBody b2 = sceneBodies[numBody-1];
sceneJoints[numJoint] = new PhysicsJoint(b1, b2, (b2.position), 0, (uint)numBody-1);
</pre></div>
<!-- end-of-code-block -->
<div class="line-block">
<div class="line">Since the anchor point is specified as (b2.position) here, the center of the (numBody-1)th rigid body of is used as the anchor point.</div>
<div class="line">After generating joint, the portion which specifies the constraint condition is the following.</div>
</div>
<div class="highlight"><pre>sceneJoints[numJoint].axis1Lim = new Vector2(1, 0);
sceneJoints[numJoint].axis2Lim = new Vector2(0, 1);
sceneJoints[numJoint].angleLim = 1;
</pre></div>
<!-- end-of-code-block -->
<ol class="arabic simple">
<li>Fixed for Vector2(1, 0) direction</li>
<li>Fixed for Vector2(0, 1) direction</li>
<li>Fixed for rotation</li>
</ol>
<p>Specification is performed in this order.</p>
<p>And you can check the following here.</p>
<div class="highlight"><pre>sceneJoints[numJoint].angleLim = 0;
</pre></div>
<!-- end-of-code-block -->
<p>Supposing that there is this condition, it means that this constraint is free for rotation.</p>
<p>The similar thing comes out.</p>
<div class="highlight"><pre>sceneJoints[numJoint].axis1Lim = new Vector2(0, 0);
</pre></div>
<!-- end-of-code-block -->
<p>Supposing that there is this condition, constraint for X-axis is removed, and it means free for X-axis.</p>
<p>The similar thing comes out.</p>
<div class="highlight"><pre>sceneJoints[numJoint].axis2Lim = new Vector2(0, 0);
</pre></div>
<!-- end-of-code-block -->
<p>Supposing that there is this condition, constraint for Y-axis is removed, and it means free for Y-axis.</p>
<div class="highlight"><pre>sceneJoints[numJoint].axis1Lim = new Vector2(0, 0);
sceneJoints[numJoint].axis2Lim = new Vector2(0, 0);
sceneJoints[numJoint].angleLim = 0;
</pre></div>
<!-- end-of-code-block -->
<p>Supposing that there is this condition, then there are no constraint condition at all, ant it will be the same as well as the scene which does not have any constraints.</p>
</div>
<div class="section" id="example-of-constraint-for-rotation">
<h2><a class="toc-backref" href="#id31">Example of Constraint for Rotation</a></h2>
<div class="highlight"><pre>public override void InitScene ()
{

...
...
...

        // Link a box rigid body to the scene with a rotation joint（with angle constraints)
        {
                sceneBodies[numBody] = new PhysicsBody(sceneShapes[2], 10.0f);
                sceneBodies[numBody].position = new Vector2(-20.0f, 0.0f);
                sceneBodies[numBody].shapeIndex = 2;
                numBody++;

                PhysicsBody b1 = sceneBodies[0];
                PhysicsBody b2 = sceneBodies[numBody-1];
                sceneJoints[numJoint] = new PhysicsJoint(b1, b2, (b2.position), 0, (uint)numBody-1);
                sceneJoints[numJoint].axis1Lim = new Vector2(1, 0);
                sceneJoints[numJoint].axis2Lim = new Vector2(0, 1);
                sceneJoints[numJoint].angleLim = 1;
                sceneJoints[numJoint].angleLower = PhysicsUtility.GetRadian(-45.0f);
                sceneJoints[numJoint].angleUpper = PhysicsUtility.GetRadian(45.0f);
                numJoint++;
        }
</pre></div>
<!-- end-of-code-block -->
<p>It is the following portions that are performing -45 degree to 45 degree with restrictions for rotation.</p>
<div class="highlight"><pre>sceneJoints[numJoint].angleLim = 1;
sceneJoints[numJoint].angleLower = PhysicsUtility.GetRadian(-45.0f);
sceneJoints[numJoint].angleUpper = PhysicsUtility.GetRadian(45.0f);
</pre></div>
<!-- end-of-code-block -->
<div class="line-block">
<div class="line">Although restriction of rotation has started, not only angleLim but angleLower and angleUpper are specified,</div>
<div class="line">and -45 degrees and 45 degrees are specified, respectively.</div>
<div class="line">angleLower and angleUpper are the variables which set up the minimum and maximum of rotation restrictions.</div>
<div class="line">In addition, it is necessary to specify the angle by radian.</div>
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="example-of-constraint-for-vertical">
<h2><a class="toc-backref" href="#id32">Example of Constraint for Vertical</a></h2>
<div class="highlight"><pre>public override void InitScene ()
{

...
...
...

        // Link a box rigid body to the scene with a horizontal slider joint (with movement constraints)
        {
                sceneBodies[numBody] = new PhysicsBody(sceneShapes[2], 10.0f);
                sceneBodies[numBody].position = new Vector2(0.0f, 0.0f);
                sceneBodies[numBody].shapeIndex = 2;
                numBody++;

                PhysicsBody b1 = sceneBodies[0];
                PhysicsBody b2 = sceneBodies[numBody-1];
                sceneJoints[numJoint] = new PhysicsJoint(b1, b2, (b2.position), 0, (uint)numBody-1);
                sceneJoints[numJoint].axis1Lim = new Vector2(1, 0);
                sceneJoints[numJoint].axis2Lim = new Vector2(0, 1);
                sceneJoints[numJoint].axis2Lower = -10.0f;
                sceneJoints[numJoint].axis2Upper = 10.0f;
                sceneJoints[numJoint].angleLim = 1;
                numJoint++;
        }
</pre></div>
<!-- end-of-code-block -->
<p>It is the following portions that are performing the constraint from -10 m to +10 m with Y-axis restrictions.</p>
<div class="highlight"><pre>sceneJoints[numJoint].axis2Lim = new Vector2(0, 1);
sceneJoints[numJoint].axis2Lower = -10.0f;
sceneJoints[numJoint].axis2Upper = 10.0f;
</pre></div>
<!-- end-of-code-block -->
<div class="line-block">
<div class="line">Although restriction of Y-axis has started, not only axis2Lim but axis2Lower and axis2Upper are specified,</div>
<div class="line">Therefore, rigid body can move now in the direction of the Y-axis freely with restrictions from an anchor point between -10m and +10m.</div>
<div class="line">axis2Lower and axis2Upper are the variables which set up the minimum and maximum of position constraint.</div>
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="example-of-constraint-for-horizontal">
<h2><a class="toc-backref" href="#id33">Example of Constraint for Horizontal</a></h2>
<div class="highlight"><pre>public override void InitScene ()
{

...
...
...

// Link a box rigid body to the scene with a horizontal slider joint (with movement constraints)
{
        sceneBodies[numBody] = new PhysicsBody(sceneShapes[2], 10.0f);
        sceneBodies[numBody].position = new Vector2(0.0f, 0.0f);
        sceneBodies[numBody].shapeIndex = 2;
        numBody++;

        PhysicsBody b1 = sceneBodies[0];
        PhysicsBody b2 = sceneBodies[numBody-1];
        sceneJoints[numJoint] = new PhysicsJoint(b1, b2, (b2.position), 0, (uint)numBody-1);
        sceneJoints[numJoint].axis1Lim = new Vector2(1, 0);
        sceneJoints[numJoint].axis1Lower = -10.0f;
        sceneJoints[numJoint].axis1Upper = 10.0f;
        sceneJoints[numJoint].axis2Lim = new Vector2(0, 1);
        sceneJoints[numJoint].angleLim = 1;
        numJoint++;

    // The horizontal slider joint is quite slippy,
    // so to make the rigid body stop we add some air friction
        b2.airFriction = 0.01f;
}
</pre></div>
<!-- end-of-code-block -->
<p>Horizontal restrictions are set up like the example of the move restrictions which can be set to vertical.</p>
<div class="highlight"><pre>sceneJoints[numJoint].axis1Lim = new Vector2(1, 0);
sceneJoints[numJoint].axis1Lower = -10.0f;
sceneJoints[numJoint].axis1Upper = 10.0f;
</pre></div>
<!-- end-of-code-block -->
<div class="line-block">
<div class="line">Therefore, rigid body can move now in the direction of the X-axis freely with restrictions from an anchor point between -10m and +10m.</div>
<div class="line"><br /></div>
<div class="line">It may arise that the object which is moving horizontally does not stop easily</div>
<div class="line">because gravity is not applied horizontally when movement is horizontally permitted with restrictions here,</div>
<div class="line">therefore it has set up to give air resistance to a rigid body.</div>
</div>
<div class="highlight"><pre>// The horizontal slider joint is quite slippy,
// so to make the rigid body stop we add some air friction
b2.airFriction = 0.01f;
</pre></div>
<!-- end-of-code-block -->
<div class="line-block">
<div class="line">The air resistance coefficient of 0.01f is given to the (numBody-1)th rigid body,</div>
<div class="line">and it has prevented continuing sliding minutely horizontally by air resistance.</div>
</div>
</div>
</div>
 </div></div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Events</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<!--<div id="footer">-->


<!--<div id="footer">-->
<div id="footer2">
<p>&copy;2013 Sony Computer Entertainment Inc. All Rights Reserved.</p></div>




</body>
</html>
